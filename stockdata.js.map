{"version":3,"file":"stockdata.js","sources":["src/stockdata-query.js","src/stockdata-update.js"],"sourcesContent":["/**\n * TODO:\n * 1. 数据结构（对应到本地或远程存储结构）\n *\n *\n * 股票数据访问层，主要用于计算和一些处理\n * 1. 后续会将数据的远程访问，本地访问在这里集成\n * 2.\n */\n\nconst _ = require(\"lodash\");\n\nconst os = require(\"os\");\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst fp = fs.promises;\n\nconst pino = require(\"pino\");\n\nconst logger = pino({\n    level: process.env.LOGGER || \"info\",\n    prettyPrint: {\n        levelFirst: true,\n        translateTime: \"SYS:yyyy-yy-dd HH:MM:ss.l\",\n        crlf: true,\n    },\n    prettifier: require(\"pino-pretty\"),\n});\n\nconst DATA_ROOT = \".wtda\";\nconst DAILYHISTORY_PATH = \"daily\";\nconst INFO_PATH = \"info\";\nconst STOCKLIST_FILE = \"stock-list.json\";\nconst INDEXLIST_FILE = \"index-list.json\";\n\nfunction getDataRoot() {\n    return path.join(os.homedir(), DATA_ROOT);\n}\n\n/**\n * 读取目前可用的完整股票列表返回，返回数据为对象\n * {\n *    info: {\n *      updateTime,\n *      ...\n *    }\n *    data: stockList[]\n * }\n *\n * stockList: [{\n *    ts_code,\n *    symbol,\n *    name,\n *    area,\n *    industry,\n *    fullname,\n *    enname,\n *    market,\n *    exchange,\n *    curr_type,\n *    list_status,\n *    delist_date,\n *    is_hs\n * }]\n *\n */\nasync function readStockList() {\n    let retData = null;\n    try {\n        await checkDataPath();\n\n        // 首先从目录中读取对应的列表文件，然后根据文件当中的信息决定是否需要更新\n        let stockListPath = path.join(getDataRoot(), STOCKLIST_FILE);\n        retData = JSON.parse(await fp.readFile(stockListPath, \"utf-8\"));\n        if (!_.isEmpty(retData)) {\n            logger.debug(`股票列表更新时间 @${retData.updateTime}`);\n        }\n    } catch (error) {\n        logger.error(`读取股票列表数据错误：${error}`);\n        throw new Error(\n            \"读取股票列表过程中出现错误，请检查后重新运行：\" + error\n        );\n        // retData = null\n    }\n\n    if (_.isEmpty(retData)) {\n        // 读取数据不存在\n        return {\n            updateTime: \"\",\n            data: [],\n        };\n    }\n    return retData;\n}\n\nasync function readStockIndexList() {\n    let retData = null;\n    try {\n        await checkDataPath();\n\n        // 首先从目录中读取对应的列表文件，然后根据文件当中的信息决定是否需要更新\n        let stockIndexListPath = path.join(getDataRoot(), INDEXLIST_FILE);\n        retData = JSON.parse(await fp.readFile(stockIndexListPath, \"utf-8\"));\n        if (!_.isEmpty(retData)) {\n            logger.debug(`指数列表更新时间 @${retData.updateTime}`);\n        }\n    } catch (error) {\n        logger.error(`读取指数列表数据错误：${error}`);\n        throw new Error(\n            \"读取指数列表过程中出现错误，请检查后重新运行：\" + error\n        );\n        // retData = null\n    }\n\n    if (_.isEmpty(retData)) {\n        // 读取数据不存在\n        return {\n            updateTime: \"\",\n            data: [],\n        };\n    }\n    return retData;\n}\n\nasync function readStockDaily(tsCode) {\n    if (_.isEmpty(tsCode)) {\n        throw new Error(\"未设置读取股票代码\");\n    }\n    let dailyData = {\n        updateTime: null,\n        data: [],\n    };\n    try {\n        await checkDataPath();\n\n        let stockDailyHistoryFile = path.join(\n            getDataRoot(),\n            DAILYHISTORY_PATH,\n            tsCode + \".json\"\n        );\n        try {\n            // await fp.access(stockDailyHistoryFile, fs.constants.F_OK)\n            dailyData = JSON.parse(\n                await fp.readFile(stockDailyHistoryFile, \"utf-8\")\n            );\n        } catch (error) {\n            // logger.debug(\"读取本地日线数据错误\", error)\n            // 文件不存在，不考虑其它错误\n            dailyData = { data: [] };\n        }\n    } catch (error) {\n        logger.error(`从本地读取日线数据时发生错误 ${error}`);\n    }\n    return dailyData;\n}\n\nasync function readStockAdjustFactor(tsCode) {\n    if (_.isEmpty(tsCode)) {\n        throw new Error(\"未设置读取股票代码\");\n    }\n    let adjData = {\n        updateTime: null,\n        data: [],\n    };\n    try {\n        await checkDataPath();\n\n        let stockAdjFile = path.join(\n            getDataRoot(),\n            DAILYHISTORY_PATH,\n            tsCode + \".adj.json\"\n        );\n        try {\n            adjData = JSON.parse(await fp.readFile(stockAdjFile, \"utf-8\"));\n        } catch (error) {\n            logger.debug(`读取股票复权因子文件${stockAdjFile} 错误：${error}`);\n            adjData = {\n                updateTime: null,\n                data: [],\n            };\n        }\n    } catch (error) {\n        logger.error(`从本地读取日线复权因子数据时发生错误 ${error}`);\n    }\n    return adjData;\n}\n\nasync function readStockDailyBasic(tsCode) {\n    if (_.isEmpty(tsCode)) {\n        throw new Error(\"未设置读取股票代码\");\n    }\n    let basicData = {\n        updateTime: null,\n        data: [],\n    };\n    try {\n        await checkDataPath();\n\n        let stockBasicFile = path.join(\n            getDataRoot(),\n            INFO_PATH,\n            tsCode + \".info.json\"\n        );\n        try {\n            basicData = JSON.parse(await fp.readFile(stockBasicFile, \"utf-8\"));\n        } catch (error) {\n            logger.debug(`读取基本面文件${stockBasicFile} 错误：${error}`);\n            basicData = {\n                updateTime: null,\n                data: [],\n            };\n        }\n    } catch (error) {\n        logger.error(`从本地读取基本面数据时发生错误 ${error}`);\n    }\n    return basicData;\n}\n\nasync function checkDataPath() {\n    let dataPath = getDataRoot(); // path.join(os.homedir, DATA_ROOT)\n\n    // 做基础的目录访问检查\n    try {\n        await fp.access(\n            dataPath,\n            fs.constants.F_OK | fs.constants.R_OK | fs.constants.W_OK\n        );\n    } catch (error) {\n        logger.debug(`检查数据根目录错误 ${error}`);\n        await fp.mkdir(dataPath, { recursive: true });\n    }\n\n    let dailyPath = path.join(dataPath, DAILYHISTORY_PATH);\n    try {\n        await fp.access(\n            dailyPath,\n            fs.constants.F_OK | fs.constants.R_OK | fs.constants.W_OK\n        );\n    } catch (error) {\n        logger.debug(`检查日线历史目录错误 ${error}`);\n        await fp.mkdir(dailyPath, { recursive: true });\n    }\n\n    let infoPath = path.join(dataPath, INFO_PATH);\n    try {\n        await fp.access(\n            infoPath,\n            fs.constants.F_OK | fs.constants.R_OK | fs.constants.W_OK\n        );\n    } catch (error) {\n        logger.debug(`检查信息数据目录错误 ${error}`);\n        await fp.mkdir(infoPath, { recursive: true });\n    }\n}\n\nexport {\n    readStockList,\n    readStockIndexList,\n    readStockDaily,\n    readStockAdjustFactor,\n    readStockDailyBasic,\n    checkDataPath,\n    getDataRoot,\n    DATA_ROOT,\n    DAILYHISTORY_PATH,\n    INFO_PATH,\n    STOCKLIST_FILE,\n    INDEXLIST_FILE,\n};\n","/**\n * TODO:\n * 1. 数据结构（对应到本地或远程存储结构）\n *\n *\n * 股票数据访问层，主要用于计算和一些处理\n * 1. 后续会将数据的远程访问，本地访问在这里集成\n * 2.\n */\n\nconst _ = require(\"lodash\");\nconst moment = require(\"moment\");\nconst executeTasks = require(\"@wt/lib-taskqueue\");\nconst tushare = require(\"@wt/lib-tushare\");\n\nconst pino = require(\"pino\");\n\nconst logger = pino({\n    level: process.env.LOGGER || \"info\",\n    prettyPrint: {\n        levelFirst: true,\n        translateTime: \"SYS:yyyy-yy-dd HH:MM:ss.l\",\n        crlf: true,\n    },\n    prettifier: require(\"pino-pretty\"),\n});\n\nimport {\n    // readStockList,\n    // readStockIndexList,\n    readStockDaily,\n    readStockAdjustFactor,\n    readStockDailyBasic,\n    checkDataPath,\n    getDataRoot,\n    DAILYHISTORY_PATH,\n    INFO_PATH,\n    STOCKLIST_FILE,\n    INDEXLIST_FILE,\n} from \"./stockdata-query\";\n\n// const os = require(\"os\")\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst fp = fs.promises;\n\nconst QUEUE_MAX = 20;\n// const updateControl = new FlowControl(QUEUE_MAX, 0, \"更新数据控制池\");\n\n/**\n * 数据更新，如果force为true，则需要将所有数据更新为最新（相当于全部重新读取）\n * @param {boolean} force 强制更新所有数据，表示忽略本地数据，重新获取全部历史数据\n * @param {boolean} includeStock 是否更新股票日线数据，默认不更新\n * @param {boolean} includeFactor 是否更新日线复权因子数据，默认不更新\n * @param {boolean} includeBasic 是否更新股票基本面资料，默认不更新\n * @param {boolean} includeIndex 是否更新指数日线，默认不更新\n */\nasync function updateData(\n    force = false,\n    includeStock = false,\n    includeFactor = false,\n    includeBasic = false,\n    includeIndex = false,\n    all = false\n) {\n    let now = moment();\n    // let endDate = now.format(\"YYYYMMDD\")\n\n    logger.info(\"获取和更新股票列表数据 ...\");\n    logger.debug(\n        `参数：强制更新 ${force}, 全部更新 ${all}，更新股票日线 ${includeStock}, 更新指数日线 ${includeIndex}`\n    );\n    // 首先更新股票列表数据\n    let stockBasicData = await tushare.stockBasic();\n\n    let stockList = {\n        updateTime: now.toISOString(),\n        data: stockBasicData,\n    };\n    await saveListFile(stockList, STOCKLIST_FILE);\n    logger.info(\"股票列表数据更新完毕！\");\n\n    logger.info(\"获取和更新指数列表数据 ...\");\n    // 更新股票指数列表数据\n    let indexList = {\n        updateTime: now.toISOString(),\n        data: [],\n    };\n\n    // logger.debug(\"开始请求指数数据：\")\n    let allIndexData = await Promise.all(\n        tushare.indexMarketList.map(async (market) => {\n            return tushare.indexBasic(market.code);\n            // logger.debug(\"返回指数基础数据：\", indexBasicData)\n            // return indexBasicData\n        })\n    );\n\n    // logger.debug(\"所有指数请求返回！\", allIndexData && allIndexData.length)\n    if (allIndexData && allIndexData.length > 0) {\n        allIndexData.forEach((data) => {\n            // logger.debug(\"指数数据：\", data && data.length)\n            if (data && data.length > 0) {\n                // 合并之前做一次数据检查，对于已经终止的指数进行过滤\n                let total = data.length;\n                data = data.filter((item) => {\n                    return _.isEmpty(item.exp_date);\n                });\n                let filteredTotal = data.length;\n                logger.debug(`指数过滤，总共${total}, 剩余${filteredTotal}`);\n                indexList.data.push(...data);\n            }\n        });\n    }\n    // logger.debug(\"保存指数数据！\")\n    await saveListFile(indexList, INDEXLIST_FILE);\n    logger.info(\"更新指数列表数据完成！\");\n\n    if (all || includeStock) {\n        logger.info(\"开始更新股票日线数据...\");\n        // 这里直接采用Promise的方式\n        if (_.isArray(stockBasicData) && stockBasicData.length > 0) {\n            let tasks = stockBasicData.map((item) => {\n                return {\n                    caller: updateDailyData,\n                    args: [item.ts_code, force, \"S\"],\n                };\n            });\n\n            let workers = executeTasks(tasks, 20, \"股票日线更新任务\");\n\n            try {\n                logger.debug(\"等待股票日线更新队列完成...\");\n                await Promise.all(workers);\n                logger.debug(\"股票日线更新队列全部执行完毕！\");\n            } catch (error) {\n                logger.error(`股票日线任务执行 错误！${error}`);\n            }\n        }\n        logger.info(tushare.showInfo());\n        logger.info(\"股票日线数据更新完毕!\");\n    }\n\n    if (all || includeFactor) {\n        logger.info(\"开始更新股票复权因子数据...\");\n        // 这里直接采用Promise的方式\n        if (_.isArray(stockBasicData) && stockBasicData.length > 0) {\n            let tasks = stockBasicData.map((item) => {\n                return {\n                    caller: updateAdjustFactorData,\n                    args: [item.ts_code, force],\n                };\n            });\n            let workers = executeTasks(tasks, 20, \"股票复权因子更新任务\");\n            try {\n                logger.debug(\"等待股票日线复权因子更新队列完成...\");\n                await Promise.all(workers);\n                logger.debug(\"股票日线复权因子更新队列全部执行完毕！\");\n            } catch (error) {\n                logger.error(`股票日线复权因子任务执行 错误！${error}`);\n            }\n        }\n\n        logger.info(tushare.showInfo());\n        logger.info(\"股票复权因子数据更新完毕!\");\n    }\n\n    if (all || includeBasic) {\n        logger.info(\"开始更新基本面数据...\");\n        // 这里直接采用Promise的方式\n        if (_.isArray(stockBasicData) && stockBasicData.length > 0) {\n            let tasks = stockBasicData.map((item) => {\n                return {\n                    caller: updateDailyBasicData,\n                    args: [item.ts_code, force],\n                };\n            });\n            let workers = executeTasks(tasks, 20, \"基本面更新任务\");\n            try {\n                logger.debug(\"等待基本面数据更新队列完成...\");\n                await Promise.all(workers);\n                logger.debug(\"基本面数据更新队列全部执行完毕！\");\n            } catch (error) {\n                logger.error(`股票基本面更新任务执行 错误！${error}`);\n            }\n        }\n\n        logger.info(tushare.showInfo());\n        logger.info(\"股票基本面数据更新完毕!\");\n    }\n\n    // For test\n    // let tmp = stockBasicData[0]\n    // await updateDailyData(tmp, force\n    if (all || includeIndex) {\n        logger.info(\"指数日线数据更新开始 ...\");\n        if (_.isArray(indexList.data) && indexList.data.length > 0) {\n            // indexList.data.forEach((data) => {\n            //     updateControl.call(updateDailyData, data.ts_code, force, \"I\");\n            // });\n            let tasks = indexList.data.map((data) => {\n                return {\n                    caller: updateDailyData,\n                    args: [data.ts_code, force, \"I\"],\n                };\n            });\n            let workers = executeTasks(tasks, 20, \"指数日线更新任务\");\n\n            try {\n                logger.debug(\"等待指数日线更新队列完成 ...\");\n                await Promise.all(workers);\n                logger.debug(\"指数日线数据更新队列全部完成！\");\n            } catch (error) {\n                logger.error(`指数日线任务执行 错误：%o`, error);\n            }\n\n            logger.info(tushare.showInfo());\n            logger.info(\"指数日线数据更新完毕！\");\n        }\n    }\n\n    // logger.log(tushare.showInfo());\n}\n\n/**\n * 更新指定代码的日历史数据\n * @param {string} tsCode 代码\n * @param {boolean} force 是否强制更新\n * @param {string} type 股票类型，S表示普通股票，I表示指数\n */\nasync function updateDailyData(tsCode, force = false, type = \"S\") {\n    // logger.log(\"更新日线：\", tsCode, force)\n    if (_.isEmpty(tsCode)) {\n        return { data: [] };\n    }\n    if (type !== \"S\" && type !== \"I\") {\n        return { data: [] };\n    }\n\n    // let tsCode = data.ts_code\n    // logger.log(\"执行更新日线：\", tsCode, force)\n    let dailyData;\n    try {\n        if (force) {\n            logger.debug(`force update ${tsCode}`);\n            let data;\n            if (type === \"S\") {\n                data = await tushare.stockDaily(tsCode);\n            } else {\n                data = await tushare.indexDaily(tsCode);\n            }\n            dailyData = {\n                updateTime: moment().toISOString(),\n                data,\n            };\n            logger.info(\n                `日线数据强制更新，代码 ${tsCode}, 更新时间：${\n                    dailyData.updateTime\n                }, 总条数：${dailyData.data && dailyData.data.length}`\n            );\n        } else {\n            dailyData = await readStockDaily(tsCode);\n\n            let startDate = \"\";\n            if (dailyData.data && dailyData.data.length > 0) {\n                let lastDate = dailyData.data[0].trade_date;\n                startDate = moment(lastDate, \"YYYYMMDD\")\n                    .add(1, \"days\")\n                    .format(\"YYYYMMDD\");\n                let now = moment();\n                if (now.diff(startDate, \"days\") <= 0 && now.hours() < 15) {\n                    // 还没有最新一天的数据，不需要\n                    logger.log(`没有新的数据，不需要更新 ${tsCode}`);\n                    return;\n                }\n            }\n\n            let newData;\n            if (type === \"S\") {\n                newData = await tushare.stockDaily(tsCode, startDate);\n            } else {\n                newData = await tushare.indexDaily(tsCode, startDate);\n            }\n            if (newData && newData.length > 0) {\n                dailyData.updateTime = moment().toISOString();\n                dailyData.data.unshift(...newData);\n                logger.info(\n                    `日线数据更新，代码 ${tsCode}, 更新时间：${\n                        dailyData.updateTime\n                    }, 更新条数：${newData && newData.length}，总条数：${\n                        dailyData.data && dailyData.data.length\n                    }`\n                );\n            } else {\n                dailyData = null;\n                logger.info(`日线数据没有更新，代码 ${tsCode}`);\n            }\n        }\n    } catch (error) {\n        logger.error(`${tsCode} 日线数据更新时发生错误，${error}`);\n        throw error;\n    }\n\n    try {\n        if (dailyData) {\n            await checkDataPath();\n\n            let jsonStr = JSON.stringify(dailyData);\n            let stockDailyFile = path.join(\n                getDataRoot(),\n                DAILYHISTORY_PATH,\n                tsCode + \".json\"\n            );\n            await fp.writeFile(stockDailyFile, jsonStr, \"utf-8\");\n        }\n    } catch (error) {\n        throw new Error(\n            \"保存日线历史数据时出现错误，请检查后重新执行：\" +\n                tsCode +\n                \",\" +\n                error\n        );\n    }\n}\n\n/**\n * 更新指定代码的复权因子历史数据\n * @param {string} tsCode 代码\n * @param {boolean} force 是否强制更新\n */\nasync function updateAdjustFactorData(tsCode, force = false) {\n    // logger.log(\"更新日线：\", tsCode, force)\n    if (_.isEmpty(tsCode)) {\n        return { data: [] };\n    }\n\n    // let tsCode = data.ts_code\n    // logger.log(\"执行更新日线：\", tsCode, force)\n    let adjData;\n    try {\n        if (force) {\n            logger.debug(`force update ${tsCode}`);\n            adjData = {\n                updateTime: moment().toISOString(),\n                data: await tushare.adjustFactor(tsCode),\n            };\n\n            logger.info(\n                `股票复权因子数据强制更新，代码 ${tsCode}, 总条数：${\n                    adjData.data && adjData.data.length\n                }`\n            );\n        } else {\n            adjData = await readStockAdjustFactor(tsCode);\n\n            let startDate = \"\";\n            if (adjData.data && adjData.data.length > 0) {\n                let lastDate = adjData.data[0].trade_date;\n                startDate = moment(lastDate, \"YYYYMMDD\")\n                    .add(1, \"days\")\n                    .format(\"YYYYMMDD\");\n                let now = moment();\n                if (now.diff(startDate, \"days\") <= 0 && now.hours() < 15) {\n                    // 还没有最新一天的数据，不需要\n                    logger.debug(`没有新的复权因子数据，不需要更新 ${tsCode}`);\n                    return;\n                }\n            }\n\n            let newAdjData = await tushare.adjustFactor(tsCode, startDate);\n            logger.debug(\n                `${tsCode} 复权因子数据返回：${newAdjData && newAdjData.length}`\n            );\n            if (newAdjData && newAdjData.length > 0) {\n                adjData.updateTime = moment().toISOString();\n                adjData.data.unshift(...newAdjData);\n                logger.info(\n                    `日线复权因子数据更新，代码 ${tsCode}, 更新条数：${\n                        newAdjData && newAdjData.length\n                    }，总条数：${adjData.data && adjData.data.length}`\n                );\n            } else {\n                adjData = null;\n                logger.info(`日线复权因子数据没有更新，代码 ${tsCode}`);\n                return;\n            }\n        }\n    } catch (error) {\n        logger.error(`${tsCode} 日线复权因子数据更新时发生错误，${error}`);\n        throw error;\n    }\n\n    try {\n        if (adjData && adjData.data && adjData.data.length > 0) {\n            let jsonStr = JSON.stringify(adjData);\n            let adjFile = path.join(\n                getDataRoot(),\n                DAILYHISTORY_PATH,\n                tsCode + \".adj.json\"\n            );\n            await fp.writeFile(adjFile, jsonStr, \"utf-8\");\n        }\n    } catch (error) {\n        throw new Error(\n            \"保存复权因子数据时出现错误，请检查后重新执行：\" +\n                tsCode +\n                \",\" +\n                error\n        );\n    }\n}\n\nasync function updateDailyBasicData(tsCode, force = false) {\n    if (_.isEmpty(tsCode)) {\n        return { data: [] };\n    }\n\n    let adjData;\n    try {\n        if (force) {\n            logger.debug(`force update ${tsCode}`);\n            adjData = {\n                updateTime: moment().toISOString(),\n                data: await tushare.dailyBasic(tsCode),\n            };\n\n            logger.info(\n                `股票基本面数据强制更新，代码 ${tsCode}, 总条数：${\n                    adjData.data && adjData.data.length\n                }`\n            );\n        } else {\n            adjData = await readStockDailyBasic(tsCode);\n\n            let startDate = \"\";\n            if (adjData && adjData.data && adjData.data.length > 0) {\n                let lastDate = adjData.data[0].trade_date;\n                startDate = moment(lastDate, \"YYYYMMDD\")\n                    .add(1, \"days\")\n                    .format(\"YYYYMMDD\");\n                let now = moment();\n                if (now.diff(startDate, \"days\") <= 0 && now.hours() < 15) {\n                    // 还没有最新一天的数据，不需要\n                    logger.debug(\n                        `没有新的股票基本面数据，不需要更新 ${tsCode}`\n                    );\n                    return;\n                }\n            }\n\n            let newData = await tushare.dailyBasic(tsCode, startDate);\n            logger.debug(\n                `${tsCode} 基本面数据返回：${newData && newData.length}`\n            );\n            if (newData && newData.length > 0) {\n                adjData.updateTime = moment().toISOString();\n                adjData.data.unshift(...newData);\n                logger.info(\n                    `基本面数据更新，代码 ${tsCode}, 更新条数：${\n                        newData && newData.length\n                    }，总条数：${adjData.data && adjData.data.length}`\n                );\n            } else {\n                adjData = null;\n                logger.info(`基本面数据没有更新，代码 ${tsCode}`);\n                return;\n            }\n        }\n    } catch (error) {\n        logger.error(`${tsCode} 基本面数据更新时发生错误，${error}`);\n        throw error;\n    }\n\n    try {\n        if (adjData && adjData.data && adjData.data.length > 0) {\n            let jsonStr = JSON.stringify(adjData);\n            let adjFile = path.join(\n                getDataRoot(),\n                INFO_PATH,\n                tsCode + \".basic.json\"\n            );\n            await fp.writeFile(adjFile, jsonStr, \"utf-8\");\n        }\n    } catch (error) {\n        throw new Error(\n            \"保存基本面数据时出现错误，请检查后重新执行：\" +\n                tsCode +\n                \",\" +\n                error\n        );\n    }\n}\n\n/**\n * 通过日期将复权因子数据合并到日线数据中，可以在后续的使用中直接使用\n * @param {Array} dailyData 日线数据\n * @param {Array} adjData 复权因子数据\n */\nasync function combineAdjustFactors(dailyData, adjData) {\n    // let retData = [];\n    if (dailyData && dailyData.length > 0) {\n        dailyData = dailyData.map((daily) => {\n            let findIndex = adjData.findIndex((adj, j) => {\n                return adj.trade_date === daily.trade_date;\n            });\n            if (findIndex >= 0 && findIndex < dailyData.length) {\n                let adj = adjData.splice(findIndex, 1)[0];\n                daily.adj_factor = adj.adj_factor;\n                // logger.debug(\n                //     `找到${daily.trade_date} 复权因子 ${adj.adj_factor}, %o`,\n                //     adj\n                // );\n            } else {\n                logger.debug(`没有找到${daily.trade_date}的复权因子`);\n            }\n            return daily;\n        });\n    }\n    return [dailyData, adjData];\n}\n\n// async function saveStockList(data) {\n//     try {\n//         await checkDataPath()\n\n//         let jsonStr = JSON.stringify(data)\n//         let stockListPath = path.join(getDataRoot(), STOCKLIST_FILE)\n\n//         await fp.writeFile(stockListPath, jsonStr, {encoding: \"utf-8\"})\n//     } catch (error) {\n//         throw new Error(\"保存股票列表数据时出现错误，请检查后重新执行：\" + error)\n//     }\n// }\n\nasync function saveListFile(data, fileName) {\n    try {\n        await checkDataPath();\n\n        let jsonStr = JSON.stringify(data);\n        let listPath = path.join(getDataRoot(), fileName);\n\n        await fp.writeFile(listPath, jsonStr, { encoding: \"utf-8\" });\n    } catch (error) {\n        throw new Error(\"保存列表数据时出现错误，请检查后重新执行：\" + error);\n    }\n}\n\n/**\n * 清除所有已经同步的数据\n */\nasync function clearAllData() {\n    try {\n        logger.debug(\"检查根目录状态：\");\n        await checkDataPath();\n\n        // 首先删除股票列表信息文件\n        logger.info(\"清理股票列表数据...\");\n        let stockListPath = path.join(getDataRoot(), STOCKLIST_FILE);\n        try {\n            await fp.access(stockListPath, fs.constants.F_OK);\n            try {\n                await fp.unlink(stockListPath);\n            } catch (error) {\n                throw error;\n            }\n        } catch (error) {\n            // 文件不存在，直接忽略\n        }\n        logger.info(\"清理股票列表数据完成\");\n\n        logger.info(\"清理指数列表数据...\");\n        let indexListPath = path.join(getDataRoot(), INDEXLIST_FILE);\n        try {\n            await fp.access(indexListPath, fs.constants.F_OK);\n            try {\n                await fp.unlink(indexListPath);\n            } catch (error) {\n                throw error;\n            }\n        } catch (error) {\n            // 文件不存在，直接忽略\n        }\n        logger.info(\"清理指数列表数据完成\");\n\n        logger.info(\"清理股票历史数据...\");\n        // 下面删除股票历史数据目录\n        let stockDailyHistoryPath = path.join(getDataRoot(), DAILYHISTORY_PATH);\n        try {\n            await fp.access(stockDailyHistoryPath, fs.constants.F_OK);\n\n            try {\n                let fileList = await fp.readdir(stockDailyHistoryPath);\n                logger.info(`共有${fileList.length}个历史数据文件待删除`);\n                fileList.forEach(async (filePath) => {\n                    // logger.log(\"to be remove: \", filePath)\n                    await fp.unlink(path.join(stockDailyHistoryPath, filePath));\n                });\n            } catch (error) {\n                throw error;\n            }\n        } catch (error) {\n            // 没有目录\n        }\n        logger.info(\"清理股票历史数据完成\");\n    } catch (error) {\n        throw new Error(\"清除所有已经同步数据发生错误：\" + error);\n    }\n}\n\nexport {\n    clearAllData,\n    updateData,\n    updateDailyData,\n    updateAdjustFactorData,\n    updateDailyBasicData,\n};\n"],"names":["_","require","os","path","fs","fp","promises","logger","pino","level","process","env","LOGGER","prettyPrint","levelFirst","translateTime","crlf","prettifier","getDataRoot","join","homedir","async","readStockDaily","tsCode","isEmpty","Error","dailyData","updateTime","data","checkDataPath","stockDailyHistoryFile","JSON","parse","readFile","error","dataPath","access","constants","F_OK","R_OK","W_OK","debug","mkdir","recursive","dailyPath","infoPath","moment","executeTasks","tushare","updateDailyData","force","type","stockDaily","indexDaily","toISOString","info","length","newData","startDate","lastDate","trade_date","add","format","now","diff","hours","log","unshift","jsonStr","stringify","stockDailyFile","writeFile","updateAdjustFactorData","adjData","adjustFactor","stockAdjFile","readStockAdjustFactor","newAdjData","adjFile","updateDailyBasicData","dailyBasic","basicData","stockBasicFile","readStockDailyBasic","saveListFile","fileName","listPath","encoding","stockListPath","unlink","indexListPath","stockDailyHistoryPath","fileList","readdir","forEach","filePath","retData","stockIndexListPath","includeStock","includeFactor","includeBasic","includeIndex","all","stockBasicData","stockBasic","stockList","indexList","allIndexData","Promise","indexMarketList","map","indexBasic","market","code","total","filteredTotal","filter","item","exp_date","push","isArray","tasks","caller","args","ts_code","workers","showInfo"],"mappings":"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"}