{"version":3,"file":"stockdata.js","sources":["src/stockdata-update.js"],"sourcesContent":["/**\n * 股票数据获取和更新\n * 1. 后续会将数据的远程访问，本地访问在这里集成\n * 2.\n */\n\nconst {\n    readStockList,\n    readStockData,\n    getDataRoot,\n    getStockDataFile,\n    DATA_PATH,\n    STOCKLIST_FILE,\n    INDEXLIST_FILE,\n    stockDataNames,\n} = require(\"@wt/lib-wtda-query\");\n\nconst _ = require(\"lodash\");\nconst moment = require(\"moment\");\nconst executeTasks = require(\"@wt/lib-taskqueue\");\nconst tushare = require(\"@wt/lib-tushare\");\n\nconst pino = require(\"pino\");\n\nconst logger = pino({\n    level: process.env.LOGGER || \"info\",\n    prettyPrint: {\n        levelFirst: true,\n        translateTime: \"SYS:yyyy-mm-dd HH:MM:ss.l\",\n        crlf: true,\n    },\n    prettifier: require(\"pino-pretty\"),\n});\n\n// const os = require(\"os\")\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst fp = fs.promises;\n\nconst stockInfo2Names = {\n    [stockDataNames.dividend]: stockDataNames.dividend,\n    [stockDataNames.pledgeStat]: stockDataNames.pledgeStat,\n    [stockDataNames.pledgeDetail]: stockDataNames.pledgeDetail,\n};\n\n/**\n * 更新个股信息数据，包括个股的日数据，基本面，复权因子，财务相关的各种数据；\n *\n * @param {string} dataName 数据名称\n * @param {string} tsCode 股票代码\n * @param {boolean} force 是否强制全部更新\n */\nasync function updateStockInfoData(dataName, tsCode, force = false) {\n    // logger.log(\"更新日线：\", tsCode, force)\n\n    // dividend 比较特殊，单独调用\n    if (stockInfo2Names[dataName]) {\n        return updateStockInfo2Data(tsCode);\n    }\n\n    if (_.isEmpty(dataName) || !stockDataNames[dataName]) {\n        throw Error(\"请填写正确的个股数据名称！\" + dataName);\n    }\n    if (_.isEmpty(tsCode)) {\n        throw Error(`请填写正确的股票代码！${tsCode}`);\n    }\n\n    let stockData;\n    try {\n        if (force) {\n            logger.debug(`需要强制更新数据：${tsCode}`);\n            try {\n                let [data, endDate, startDate] = await tushare.queryStockInfo(\n                    dataName,\n                    tsCode\n                );\n\n                stockData = {\n                    updateTime: moment().toISOString(),\n                    startDate,\n                    endDate,\n                    data,\n                };\n                logger.info(\n                    `个股数据${dataName}强制更新，代码 ${tsCode}, 更新时间：${\n                        stockData.updateTime\n                    }, 更新时间范围: ${startDate} - ${endDate}, 总条数：${\n                        stockData.data && stockData.data.length\n                    }`\n                );\n            } catch (error) {\n                logger.error(\n                    `强制更新个股${tsCode}数据${dataName}时出现错误：${error}`\n                );\n                throw error;\n            }\n        } else {\n            stockData = await readStockData(dataName, tsCode);\n\n            logger.debug(\n                `读取本地数据${tsCode}.${dataName}：${stockData.updateTime}, ${\n                    stockData.startDate\n                }, ${stockData.endDate}, ${\n                    stockData.data && stockData.data.length\n                }`\n            );\n            let startDate = null;\n            if (stockData.data && stockData.data.length > 0) {\n                let lastDate = stockData.endDate;\n                startDate = moment(lastDate, \"YYYYMMDD\")\n                    .add(1, \"days\")\n                    .format(\"YYYYMMDD\");\n                let now = moment();\n                if (now.diff(startDate, \"days\") <= 0 && now.hours() < 15) {\n                    // 还没有最新一天的数据，不需要\n                    logger.info(\n                        `${tsCode}没有新的数据${dataName}，不需要更新, 已有数据${\n                            stockData.data && stockData.data.length\n                        }条`,\n                        stockData\n                    );\n                    return;\n                }\n            }\n\n            logger.info(`${tsCode}查询数据${dataName}，参数：${startDate}`);\n            let [\n                newData,\n                endDate,\n                queryStartDate,\n            ] = await tushare.queryStockInfo(dataName, tsCode, startDate);\n            logger.info(\n                `${tsCode}查询数据${dataName}，参数：${startDate}，返回：${\n                    newData && newData.length\n                }条，${endDate}, ${queryStartDate}`\n            );\n\n            // 如果通过查询获得的数据不存在，需要更新一下startDate\n            if (stockData && !stockData.startDate) {\n                stockData.startDate = queryStartDate;\n            }\n\n            if (newData && newData.length > 0) {\n                stockData.updateTime = moment().toISOString();\n                //stockData.startDate = startDate;\n                stockData.endDate = endDate;\n                stockData.data.unshift(...newData);\n                logger.info(\n                    `个股数据${dataName}更新，代码 ${tsCode}, 更新时间：${\n                        stockData.updateTime\n                    }, 更新时间范围: ${queryStartDate} - ${endDate}, 更新条数：${\n                        newData && newData.length\n                    }，总条数：${stockData.data && stockData.data.length}`\n                );\n            } else {\n                stockData = null;\n                logger.info(`个股数据${dataName}没有更新，代码 ${tsCode}`);\n            }\n        }\n    } catch (error) {\n        logger.error(`${tsCode} 个股数据${dataName}更新时发生错误，${error}`);\n        throw error;\n    }\n\n    await saveStockDataFile(stockData, dataName, tsCode);\n}\n\nasync function saveStockDataFile(stockData, dataName, tsCode) {\n    try {\n        if (stockData && stockData.data && stockData.data.length > 0) {\n            // await checkDataPath();\n            let jsonStr = JSON.stringify(stockData);\n            let stockDataFile = getStockDataFile(dataName, tsCode);\n            logger.debug(\n                `保存个股${tsCode}数据${dataName}到：${stockDataFile}`\n            );\n            await fp.writeFile(stockDataFile, jsonStr, \"utf-8\");\n        }\n    } catch (error) {\n        throw new Error(\n            `保存个股${tsCode}数据${dataName}时出现错误，请检查后重新执行：${error}`\n        );\n    }\n}\n\n/**\n * 数据更新，如果force为true，则需要将所有数据更新为最新（相当于全部重新读取）\n * @param {boolean} force 强制更新所有数据，表示忽略本地数据，重新获取全部历史数据\n * @param {boolean} updateStock 是否更新个股日线数据，默认不更新\n * @param {boolean} updateFinance 是否更新个股财务数据，默认不更新\n * @param {boolean} updateIndex 是否更新指数信息，默认不更新\n */\nasync function updateData(\n    force = false,\n    updateStock = false,\n    updateFinance = false,\n    updateMainbiz = false,\n    updateDividend = false,\n    updatePledge = false,\n    updateIndex = false\n) {\n    logger.debug(\n        `参数：强制更新 ${force}, 更新股票信息数据 ${updateStock}, 更新股票财务数据 ${updateFinance}, 更新主营业务构成 ${updateMainbiz}, 更新分红送股 ${updateDividend}, 更新股权质押数据 ${updatePledge}，更新指数数据 ${updateIndex}`\n    );\n    // 首先读取和保存股票列表数据\n    let [stockList, indexList] = await updateListData(force);\n\n    if (updateStock) {\n        await readAndUpdateStockListInfoData(stockList, force);\n    }\n\n    if (updateFinance) {\n        await readAndUpdateStockListFinancialData(stockList, force);\n    }\n\n    if (updateMainbiz) {\n        await readAndUpdateStockListMainbizData(stockList, force);\n    }\n\n    if (updateDividend) {\n        await readAndUpdateStockListDividendData(stockList);\n    }\n\n    if (updatePledge) {\n        await readAndUpdateStockListPledgeData(stockList);\n    }\n\n    if (updateIndex) {\n        await readAndUpdateIndexListInfoData(indexList, force);\n    }\n}\n\nasync function readAndUpdateIndexListInfoData(indexList, force) {\n    if (indexList && indexList.data && indexList.data.length > 0) {\n        // if (all || includeIndex) {\n        logger.info(\"指数日线数据更新开始 ...\");\n        // if (_.isArray(indexList.data) && indexList.data.length > 0) {\n        let tasks = indexList.data.map((data) => {\n            return {\n                caller: updateStockInfoData,\n                args: [stockDataNames.indexDaily, data.ts_code, force],\n            };\n        });\n        let workers = executeTasks(tasks, 20, \"指数日线更新任务\");\n        try {\n            logger.debug(\"等待指数日线更新队列完成 ...\");\n            await Promise.all(workers);\n            logger.debug(\"指数日线数据更新队列全部完成！\");\n        } catch (error) {\n            logger.error(`指数日线任务执行 错误：%o`, error);\n        }\n        // }\n        logger.info(tushare.showInfo());\n        logger.info(\"指数日线数据更新完毕！\");\n    }\n}\n\nconst stockListInfoApiNames = [\n    stockDataNames.daily,\n    stockDataNames.adjustFactor,\n    stockDataNames.suspendInfo,\n    stockDataNames.dailyBasic,\n    stockDataNames.moneyFlow,\n];\n\nconst stockListFinancialApiNames = [\n    stockDataNames.income,\n    stockDataNames.balanceSheet,\n    stockDataNames.cashFlow,\n    stockDataNames.forecast,\n    stockDataNames.express,\n    // stockDataNames.dividend,\n    stockDataNames.financialIndicator,\n    // stockDataNames.financialMainbiz,\n    stockDataNames.disclosureDate,\n];\n\n/**\n * 读取并更新个股的财务数据\n * @param {Array} stockList 个股列表\n * @param {boolean} force 是否强制更新\n */\nasync function readAndUpdateStockListFinancialData(stockList, force) {\n    let stockBasicData = stockList && stockList.data;\n    if (stockBasicData && stockBasicData.length > 0) {\n        let tasks = [];\n        logger.info(\"个股财务数据更新准备...\");\n        for (let i = 0; i < stockBasicData.length; i++) {\n            for (let j = 0; j < stockListFinancialApiNames.length; j++) {\n                tasks.push({\n                    caller: updateStockInfoData,\n                    args: [\n                        stockListFinancialApiNames[j],\n                        stockBasicData[i].ts_code,\n                        force,\n                    ],\n                });\n            }\n        }\n        logger.info(\"个股财务数据更新准备完毕！\");\n\n        if (tasks && tasks.length > 0) {\n            let workers = executeTasks(tasks, 30, \"个股财务数据任务\");\n            try {\n                logger.debug(\"等待个股财务数据更新队列完成...\");\n                await Promise.all(workers);\n                logger.info(tushare.showInfo());\n                logger.debug(\"个股财务数据更新队列全部执行完毕！\");\n            } catch (error) {\n                logger.error(`个股财务数据更新任务执行 错误！${error}`);\n            }\n        }\n    }\n}\n\n/**\n * 读取并更新个股主营业务数据，这个数据接口流量限制较大，因此单独更新\n * @param {Array} stockList 个股列表\n * @param {boolean}} force 是否强制更新\n */\nasync function readAndUpdateStockListMainbizData(stockList, force) {\n    let stockBasicData = stockList && stockList.data;\n    if (stockBasicData && stockBasicData.length > 0) {\n        let tasks = [];\n        logger.info(\"个股主营业务数据更新准备...\");\n        for (let i = 0; i < stockBasicData.length; i++) {\n            tasks.push({\n                caller: updateStockInfoData,\n                args: [\n                    stockDataNames.financialMainbiz,\n                    stockBasicData[i].ts_code,\n                    force,\n                ],\n            });\n        }\n        logger.info(\"个股主营业务数据更新准备完毕！\");\n\n        if (tasks && tasks.length > 0) {\n            let workers = executeTasks(tasks, 30, \"个股主营业务数据任务\");\n            try {\n                logger.debug(\"等待个股主营业务数据更新队列完成...\");\n                await Promise.all(workers);\n                logger.info(tushare.showInfo());\n                logger.debug(\"个股主营业务数据更新队列全部执行完毕！\");\n            } catch (error) {\n                logger.error(`个股主营业务数据更新任务执行 错误！${error}`);\n            }\n        }\n    }\n}\n\nasync function readAndUpdateStockListDividendData(stockList) {\n    let stockBasicData = stockList && stockList.data;\n    if (stockBasicData && stockBasicData.length > 0) {\n        let tasks = [];\n        logger.info(\"个股分红送股数据更新准备...\");\n        for (let i = 0; i < stockBasicData.length; i++) {\n            tasks.push({\n                caller: updateStockInfo2Data,\n                args: [stockDataNames.dividend, stockBasicData[i].ts_code],\n            });\n        }\n        logger.info(\"个股分红送股数据更新准备完毕！\");\n\n        if (tasks && tasks.length > 0) {\n            let workers = executeTasks(tasks, 20, \"个股分红送股数据任务\");\n            try {\n                logger.debug(\"等待个股分红送股数据更新队列完成...\");\n                await Promise.all(workers);\n                logger.info(tushare.showInfo());\n                logger.debug(\"个股分红送股数据更新队列全部执行完毕！\");\n            } catch (error) {\n                logger.error(`个股分红送股数据更新任务执行 错误！${error}`);\n            }\n        }\n    }\n}\n\nasync function readAndUpdateStockListPledgeData(stockList) {\n    let stockBasicData = stockList && stockList.data;\n    if (stockBasicData && stockBasicData.length > 0) {\n        let tasks = [];\n        logger.info(\"个股股权质押数据更新准备...\");\n        for (let i = 0; i < stockBasicData.length; i++) {\n            tasks.push({\n                caller: updateStockInfo2Data,\n                args: [stockDataNames.pledgeStat, stockBasicData[i].ts_code],\n            });\n            tasks.push({\n                caller: updateStockInfo2Data,\n                args: [stockDataNames.pledgeDetail, stockBasicData[i].ts_code],\n            });\n        }\n        logger.info(\"个股股权质押数据更新准备完毕！\");\n\n        if (tasks && tasks.length > 0) {\n            let workers = executeTasks(tasks, 20, \"个股股权质押数据任务\");\n            try {\n                logger.debug(\"等待个股股权质押数据更新队列完成...\");\n                await Promise.all(workers);\n                logger.info(tushare.showInfo());\n                logger.debug(\"个股股权质押数据更新队列全部执行完毕！\");\n            } catch (error) {\n                logger.error(`个股股权质押数据更新任务执行 错误！${error}`);\n            }\n        }\n    }\n}\n\n/**\n * 读取并更新个股信息数据\n * @param {Array} stockList 个股列表\n * @param {boolean} force 是否强制更新\n */\nasync function readAndUpdateStockListInfoData(stockList, force) {\n    let stockBasicData = stockList && stockList.data;\n    if (stockBasicData && stockBasicData.length > 0) {\n        let totalStockWorkers = [];\n        logger.info(\"个股信息数据更新准备...\");\n        for (let i = 0; i < stockBasicData.length; i++) {\n            for (let j = 0; j < stockListInfoApiNames.length; j++) {\n                totalStockWorkers.push({\n                    caller: updateStockInfoData,\n                    args: [\n                        stockListInfoApiNames[j],\n                        stockBasicData[i].ts_code,\n                        force,\n                    ],\n                });\n            }\n        }\n        logger.info(\"个股信息数据更新准备完毕！\");\n        if (totalStockWorkers && totalStockWorkers.length > 0) {\n            let workers = executeTasks(\n                totalStockWorkers,\n                30,\n                \"个股数据更新任务\"\n            );\n            try {\n                logger.debug(\"等待个股数据更新队列完成...\");\n                await Promise.all(workers);\n                logger.info(tushare.showInfo());\n                logger.debug(\"个股数据更新队列全部执行完毕！\");\n            } catch (error) {\n                logger.error(`个股数据更新任务执行 错误！${error}`);\n            }\n        }\n    }\n}\n\n/**\n * 更新股票和指数列表信息\n * @param {boolean} force 是否强制更新\n */\nasync function updateListData(force) {\n    let now = moment();\n    // let endDate = now.format(\"YYYYMMDD\")\n\n    logger.info(\"获取和更新股票列表数据 ...\");\n    // 首先更新股票列表数据\n    let stockBasicData = await tushare.stockBasic();\n\n    let stockList = {\n        updateTime: now.toISOString(),\n        data: stockBasicData,\n    };\n    await saveListFile(stockList, STOCKLIST_FILE);\n    logger.info(\"股票列表数据更新完毕！\");\n\n    logger.info(\"获取和更新指数列表数据 ...\");\n    // 更新股票指数列表数据\n    let indexList = {\n        updateTime: now.toISOString(),\n        data: [],\n    };\n\n    let allIndexData = await Promise.all(\n        tushare.indexMarketList.map(async (market) => {\n            return tushare.indexBasic(market.code);\n        })\n    );\n\n    // logger.debug(\"所有指数请求返回！\", allIndexData && allIndexData.length)\n    if (allIndexData && allIndexData.length > 0) {\n        allIndexData.forEach((data) => {\n            // logger.debug(\"指数数据：\", data && data.length)\n            if (data && data.length > 0) {\n                // 合并之前做一次数据检查，对于已经终止的指数进行过滤\n                let total = data.length;\n                data = data.filter((item) => {\n                    return _.isEmpty(item.exp_date);\n                });\n                let filteredTotal = data.length;\n                logger.debug(`指数过滤，总共${total}, 剩余${filteredTotal}`);\n                indexList.data.push(...data);\n            }\n        });\n    }\n    // logger.debug(\"保存指数数据！\")\n    await saveListFile(indexList, INDEXLIST_FILE);\n    logger.info(\"更新指数列表数据完成！\");\n\n    return [stockList, indexList];\n}\n\nasync function updateStockInfo2Data(dataName, tsCode) {\n    let now = moment();\n\n    if (_.isEmpty(tsCode)) {\n        throw new Error(`没有设置查询${dataName}的个股代码`);\n    }\n\n    logger.info(`个股${tsCode}获取和更新${dataName}数据 ...`);\n    // 首先更新股票列表数据\n    let data = await tushare.queryStockInfo(dataName, tsCode);\n    let stockData = {\n        updateTime: now.toISOString(),\n        data,\n    };\n    logger.info(\n        `个股${tsCode} 数据${dataName}更新，更新时间：${\n            stockData.updateTime\n        }, 总条数：${stockData.data && stockData.data.length}`\n    );\n\n    try {\n        if (stockData && stockData.data && stockData.data.length > 0) {\n            let jsonStr = JSON.stringify(stockData);\n            let stockDataFile = getStockDataFile(dataName, tsCode);\n            logger.debug(\n                `保存个股${tsCode}数据${dataName}到：${stockDataFile}`\n            );\n            await fp.writeFile(stockDataFile, jsonStr, \"utf-8\");\n        }\n    } catch (error) {\n        logger.error(`保存个股${tsCode}数据${dataName}错误：${error}`);\n        throw new Error(\n            `保存个股${tsCode}数据${dataName}时出现错误，请检查后重新执行：${error}`\n        );\n    }\n}\n\n/**\n * 保存列表数据到指定文件\n * @param {object} data 列表数据\n * @param {string} fileName 文件名\n */\nasync function saveListFile(data, fileName) {\n    try {\n        // await checkDataPath();\n\n        let jsonStr = JSON.stringify(data);\n        let listPath = path.join(getDataRoot(), fileName);\n\n        await fp.writeFile(listPath, jsonStr, { encoding: \"utf-8\" });\n    } catch (error) {\n        throw new Error(\"保存列表数据时出现错误，请检查后重新执行：\" + error);\n    }\n}\n\n/**\n * 清除所有已经同步的数据\n */\nasync function clearAllData() {\n    try {\n        logger.debug(\"检查根目录状态：\");\n        // await checkDataPath();\n\n        // 首先删除股票列表信息文件\n        logger.info(\"清理股票列表数据...\");\n        let stockListPath = path.join(getDataRoot(), STOCKLIST_FILE);\n        try {\n            await fp.access(stockListPath, fs.constants.F_OK);\n            try {\n                await fp.unlink(stockListPath);\n            } catch (error) {\n                throw error;\n            }\n        } catch (error) {\n            // 文件不存在，直接忽略\n        }\n        logger.info(\"清理股票列表数据完成\");\n\n        logger.info(\"清理指数列表数据...\");\n        let indexListPath = path.join(getDataRoot(), INDEXLIST_FILE);\n        try {\n            await fp.access(indexListPath, fs.constants.F_OK);\n            try {\n                await fp.unlink(indexListPath);\n            } catch (error) {\n                throw error;\n            }\n        } catch (error) {\n            // 文件不存在，直接忽略\n        }\n        logger.info(\"清理指数列表数据完成\");\n\n        logger.info(\"清理股票历史数据...\");\n        // 下面删除股票历史数据目录\n        let stockDailyHistoryPath = path.join(getDataRoot(), DATA_PATH.daily);\n        try {\n            await fp.access(stockDailyHistoryPath, fs.constants.F_OK);\n\n            try {\n                let fileList = await fp.readdir(stockDailyHistoryPath);\n                logger.info(`共有${fileList.length}个历史数据文件待删除`);\n                fileList.forEach(async (filePath) => {\n                    // logger.log(\"to be remove: \", filePath)\n                    await fp.unlink(path.join(stockDailyHistoryPath, filePath));\n                });\n            } catch (error) {\n                throw error;\n            }\n        } catch (error) {\n            // 没有目录\n        }\n        logger.info(\"清理股票历史数据完成\");\n\n        logger.info(\"清理股票信息数据...\");\n        // 下面删除股票历史数据目录\n        let stockInfoPath = path.join(getDataRoot(), DATA_PATH.info);\n        try {\n            await fp.access(stockInfoPath, fs.constants.F_OK);\n\n            try {\n                let fileList = await fp.readdir(stockInfoPath);\n                logger.info(`共有${fileList.length}个历史数据文件待删除`);\n                fileList.forEach(async (filePath) => {\n                    // logger.log(\"to be remove: \", filePath)\n                    await fp.unlink(path.join(stockInfoPath, filePath));\n                });\n            } catch (error) {\n                throw error;\n            }\n        } catch (error) {\n            // 没有目录\n        }\n        logger.info(\"清理股票信息数据完成\");\n\n        logger.info(\"清理股票财务数据...\");\n        // 下面删除股票历史数据目录\n        let stockFinPath = path.join(getDataRoot(), DATA_PATH.financial);\n        try {\n            await fp.access(stockFinPath, fs.constants.F_OK);\n\n            try {\n                let fileList = await fp.readdir(stockFinPath);\n                logger.info(`共有${fileList.length}个历史数据文件待删除`);\n                fileList.forEach(async (filePath) => {\n                    // logger.log(\"to be remove: \", filePath)\n                    await fp.unlink(path.join(stockFinPath, filePath));\n                });\n            } catch (error) {\n                throw error;\n            }\n        } catch (error) {\n            // 没有目录\n        }\n        logger.info(\"清理股票财务数据完成\");\n    } catch (error) {\n        throw new Error(\"清除所有已经同步数据发生错误：\" + error);\n    }\n}\n\n/**\n * 根据股票列表和当前原始日线及复权因子数据合并完整的日线数据\n */\nasync function calculateAllDailyData() {\n    let stockList = await readStockList();\n    if (!stockList || !stockList.data) {\n        logger.error(`没有读取到股票列表，无法处理日线数据`);\n        return;\n    }\n\n    let dailyDataTasks = stockList.data.map((data) => {\n        return {\n            caller: calculateDailyData,\n            args: [data.ts_code],\n        };\n    });\n\n    if (dailyDataTasks && dailyDataTasks.length > 0) {\n        let workers = executeTasks(dailyDataTasks, 30, \"日线数据合并\");\n        try {\n            await Promise.all(workers);\n        } catch (error) {\n            logger.error(`日线数据合并任务执行发生未知异常：${error}`);\n        }\n    }\n}\n\nasync function calculateDailyData(tsCode) {\n    if (_.isEmpty(tsCode)) return;\n    let dailyData = await readStockData(stockDataNames.daily, tsCode);\n    logger.debug(`日线${tsCode}读取到${dailyData.data.length}条数据`);\n    let adjData = await readStockData(stockDataNames.adjustFactor, tsCode);\n    logger.debug(`复权因子${tsCode}读取到${adjData.data.length}条数据`);\n\n    let latestAdj =\n        adjData && adjData.data && adjData.data.length > 0\n            ? adjData.data[0].adj_factor\n            : 1;\n    logger.debug(`${tsCode}最新复权因子: ${latestAdj}`);\n\n    if (dailyData && dailyData.data && dailyData.data.length > 0) {\n        dailyData.data = dailyData.data.map((daily) => {\n            // 日线数据中需要放入对应日期的复权因子和前复权因子=复权因子/最新复权因子\n            let dates = adjData.data.filter((adj) => {\n                return adj.trade_date === daily.trade_date;\n            });\n            logger.debug(`${daily.trade_date}, 寻找到adj：%o`, dates);\n            if (dates && dates.length > 0) {\n                daily.adj_factor = dates[0].adj_factor;\n                daily.prevadj_factor = dates[0].adj_factor / latestAdj;\n            }\n            return daily;\n        });\n    }\n\n    await saveStockDataFile(dailyData, stockDataNames.daily, tsCode);\n    logger.info(`${tsCode}日线数据合并完成！`);\n}\n\nfunction calculatePrevAdjPrice(dailyData, digits = 3) {\n    if (dailyData && dailyData.data && dailyData.data.length > 0) {\n        dailyData.data.forEach((item) => {\n            if (item.prevadj_factor) {\n                item.open = Number(\n                    (item.open * item.prevadj_factor).toFixed(digits)\n                );\n                item.close = Number(\n                    (item.close * item.prevadj_factor).toFixed(digits)\n                );\n                item.high = Number(\n                    (item.high * item.prevadj_factor).toFixed(digits)\n                );\n                item.low = Number(\n                    (item.low * item.prevadj_factor).toFixed(digits)\n                );\n                item.pre_close = Number(\n                    (item.pre_close * item.prevadj_factor).toFixed(digits)\n                );\n                item.change = Number(\n                    (item.change * item.prevadj_factor).toFixed(digits)\n                );\n            }\n        });\n    }\n}\n\n// 这里的data数据应该是原始数据\n// 这里要求的数据顺序是按照日期降序的，即0放的是最新的时间\nfunction removeIncludedData(data) {\n    let ret = [];\n    if (!(data && Array.isArray(data))) return ret;\n    if (data.length <= 0) return ret;\n\n    let index = data.length - 1;\n    let item = data[index];\n\n    let currentIndex = index - 1;\n    while (currentIndex >= 0) {\n        let currentItem = data[currentIndex];\n        if (currentItem) {\n            if (currentItem.high <= item.high && currentItem.low >= item.low) {\n                // 内移日 这一天数据去除，也不需要和后续比较\n            } else {\n                // 非内移日\n                // 构造趋势数据的基本结构，数组方式[交易日，价格，类型，最高，最低]，其中价格根据类型为高点或者低点，对应当日的最高和最低值\n                let tmp = [\n                    currentItem.trade_date,\n                    null,\n                    0,\n                    currentItem.high,\n                    currentItem.low,\n                ];\n                ret.push(tmp);\n                index = currentIndex;\n                item = currentItem;\n            }\n            currentIndex = currentIndex - 1;\n        }\n    }\n    return ret;\n}\n\n/**\n * 从当前日线数据序列中计算下一级趋势点\n * 如果是第一级查找，则需要已经做好内移日去除\n * @param {Array} data 日线数据，去除内移日的原始日线数据或者某一级趋势点数据\n */\nfunction calculateNextTrendPoints(data) {\n    let findPoints = [];\n    // let nextType = 0\n    // 这里考虑使用forEach是否并行过多？\n    //data.forEach((item, index, array) => {\n    for (let index = 2; index < data.length - 2; index++) {\n        let item = data[index];\n        //if (index <= 1 || index >= array.length - 2) return;\n        let tmp = null;\n        let lastPoint =\n            findPoints.length > 0 ? findPoints[findPoints.length - 1] : null;\n        let lastType = lastPoint !== null ? lastPoint[2] : 0;\n        // findPoints.length > 0 ? findPoints[findPoints.length - 1][2] : 0\n\n        if (\n            (item[2] === 0 &&\n                item[3] >= data[index - 1][3] &&\n                item[3] >= data[index + 1][3]) ||\n            (item[2] === 1 &&\n                item[1] >= data[index - 2][1] &&\n                item[1] >= data[index + 2][1])\n        ) {\n            // 发现高点\n            tmp = [item[0], item[3], 1, item[3], item[4]];\n            logger.debug(`找到高点，序号${index}, %o`, item);\n            if (lastType === 1) {\n                logger.debug(\n                    `前一个点也是高点：, 当前序号${index}, 当前点：%o, 上一个点：%o`,\n                    tmp,\n                    lastPoint\n                );\n                if (lastPoint[1] < tmp[1]) {\n                    // 之前的高点比当前高点低，说明中间没有低点，替换之前的高点\n                    logger.debug(\"当前点价格更高，替换前一个点！\");\n                    findPoints[findPoints.length - 1] = tmp;\n                } else {\n                    logger.debug(\"之前的高点比当前点高，忽略这次发现的高点\");\n                }\n                tmp = null;\n            }\n        }\n        if (\n            (item[2] === 0 &&\n                item[4] <= data[index - 1][4] &&\n                item[4] <= data[index + 1][4]) ||\n            (item[2] === -1 &&\n                item[1] <= data[index - 2][1] &&\n                item[1] <= data[index + 2][1])\n        ) {\n            // 发现低点\n            tmp = [item[0], item[4], -1, item[3], item[4]];\n            logger.debug(`发现低点，序号${index}, %o`, item);\n            if (lastType === -1) {\n                logger.debug(\n                    `前一个点也是低点，当前序号${index}, 当前点：%o, 上一个点：%o`,\n                    tmp,\n                    lastPoint\n                );\n                if (lastPoint[1] > tmp[1]) {\n                    logger.debug(\"当前点比上一个点价格更低，替换上一个点！\");\n                    findPoints[findPoints.length - 1] = tmp;\n                } else {\n                    logger.debug(\n                        \"当前点比上一个点价格高，忽略这次发现的低点！\"\n                    );\n                }\n                tmp = null;\n            }\n        }\n        if (tmp !== null) {\n            //logger.debug(\"push trend point:\", tmp);\n            findPoints.push(tmp);\n        }\n    }\n    return findPoints;\n}\n\n/**\n * 根据当前数据计算日短期趋势\n * data输入为原始数据，在做短期高点和低点前，先去除内移交易日\n *\n * 最终的趋势数据保存在文件中，文件会包含完整前复权处理的日线数据和三级趋势数据\n */\nasync function calculateTrendPoints(tsCode) {\n    if (_.isEmpty(tsCode)) return;\n    let dailyData = await readStockData(stockDataNames.daily, tsCode);\n    // 对日数据处理前复权因子计算，处理后的数据为基准\n    calculatePrevAdjPrice(dailyData);\n\n    logger.debug(\n        `去除内移交易日..., ${\n            dailyData && dailyData.data && dailyData.data.length\n        }`\n    );\n    let indata = removeIncludedData(dailyData.data);\n    let trendPoints = [];\n\n    // 从基础数据循环3次，分别获得短期，中期和长期趋势\n    for (let i = 0; i < 3; i++) {\n        indata = calculateNextTrendPoints(indata);\n        trendPoints[i] = indata;\n        logger.debug(`趋势等级: ${i}, 趋势点数量 ${trendPoints[i].length}`);\n    }\n\n    logger.info(`${tsCode}趋势数据计算完毕！`);\n\n    try {\n        logger.info(\n            `保存数据信息：${tsCode}, 日期 ${\n                dailyData && dailyData.startDate\n            } ～ ${dailyData && dailyData.endDate}, 日线数据${\n                dailyData && dailyData.data.length\n            }条，短期${trendPoints[0].length}, 中期 ${\n                trendPoints[1].length\n            }, 长期 ${trendPoints[2].length}`\n        );\n        let stockData = {\n            updateTime: moment().toISOString(),\n            tsCode,\n            startDate: dailyData.startDate,\n            endDate: dailyData.endDate,\n            data: dailyData.data,\n            trends: trendPoints,\n        };\n        let dataName = \"trend\";\n\n        // if (stockData && stockData.data && stockData.data.length > 0) {\n        // await checkDataPath();\n        let jsonStr = JSON.stringify(stockData);\n        let stockDataFile = getStockDataFile(dataName, tsCode);\n        await fp.writeFile(stockDataFile, jsonStr, \"utf-8\");\n        // }\n        logger.info(\n            `个股${tsCode}趋势数据保存：${stockDataFile}, 短期：${\n                trendPoints && trendPoints[0].length\n            }，中期：${trendPoints && trendPoints[1].length}，长期：${\n                trendPoints && trendPoints[2].length\n            }`\n        );\n    } catch (error) {\n        throw new Error(\n            `保存个股${tsCode}趋势数据时出现错误，请检查后重新执行：${error}`\n        );\n    }\n    dailyData.data = null;\n    dailyData = null;\n    indata = null;\n\n    // return trendPoints;\n}\n\n/**\n * TODO: 需要使用前复权方式计算趋势点，目前的计算用的原始数据，对于实际股票交易盈亏而言不正确\n */\nasync function calculateAllTrendPoints() {\n    logger.info(\"内存使用：%o\", process.memoryUsage());\n    let stockList = await readStockList();\n    if (!stockList || !stockList.data) {\n        logger.error(`没有读取到股票列表，无法处理日线数据`);\n        return;\n    }\n\n    logger.info(\"内存使用：%o\", process.memoryUsage());\n    let dailyDataTasks = stockList.data.map((data) => {\n        return {\n            caller: calculateTrendPoints,\n            args: [data.ts_code],\n        };\n    });\n\n    logger.info(\"内存使用：%o\", process.memoryUsage());\n    if (dailyDataTasks && dailyDataTasks.length > 0) {\n        let workers = executeTasks(dailyDataTasks, 20, \"趋势数据计算\");\n        try {\n            await Promise.all(workers);\n        } catch (error) {\n            logger.error(`趋势数据合并任务执行发生未知异常：${error}`);\n        }\n        workers = null;\n    }\n    logger.info(`趋势数据全部计算完毕！`);\n    logger.info(\"内存使用：%o\", process.memoryUsage());\n}\n\nexport {\n    clearAllData,\n    updateData,\n    updateStockInfoData,\n    calculateAllDailyData,\n    calculateDailyData,\n    calculateAllTrendPoints,\n    calculateTrendPoints,\n    stockDataNames,\n};\n"],"names":["readStockList","readStockData","getDataRoot","getStockDataFile","DATA_PATH","STOCKLIST_FILE","INDEXLIST_FILE","stockDataNames","require","_","moment","executeTasks","tushare","logger","pino","level","process","env","LOGGER","prettyPrint","levelFirst","translateTime","crlf","prettifier","path","fs","fp","promises","stockInfo2Names","dividend","pledgeStat","pledgeDetail","async","updateStockInfoData","dataName","tsCode","force","updateStockInfo2Data","isEmpty","Error","stockData","debug","data","endDate","startDate","queryStockInfo","updateTime","toISOString","info","length","error","lastDate","add","format","now","diff","hours","newData","queryStartDate","unshift","saveStockDataFile","jsonStr","JSON","stringify","stockDataFile","writeFile","stockListInfoApiNames","daily","adjustFactor","suspendInfo","dailyBasic","moneyFlow","stockListFinancialApiNames","income","balanceSheet","cashFlow","forecast","express","financialIndicator","disclosureDate","saveListFile","fileName","listPath","join","encoding","calculateDailyData","dailyData","adjData","latestAdj","adj_factor","map","dates","filter","adj","trade_date","prevadj_factor","calculateNextTrendPoints","findPoints","index","item","tmp","lastPoint","lastType","push","calculateTrendPoints","digits","forEach","open","Number","toFixed","close","high","low","pre_close","change","calculatePrevAdjPrice","indata","ret","Array","isArray","currentIndex","currentItem","removeIncludedData","trendPoints","i","trends","stockList","dailyDataTasks","caller","args","ts_code","workers","Promise","all","memoryUsage","stockListPath","access","constants","F_OK","unlink","indexListPath","stockDailyHistoryPath","fileList","readdir","filePath","stockInfoPath","stockFinPath","financial","updateStock","updateFinance","updateMainbiz","updateDividend","updatePledge","updateIndex","indexList","stockBasicData","stockBasic","allIndexData","indexMarketList","indexBasic","market","code","total","filteredTotal","exp_date","updateListData","totalStockWorkers","j","showInfo","readAndUpdateStockListInfoData","tasks","readAndUpdateStockListFinancialData","financialMainbiz","readAndUpdateStockListMainbizData","readAndUpdateStockListDividendData","readAndUpdateStockListPledgeData","indexDaily","readAndUpdateIndexListInfoData"],"mappings":"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"}