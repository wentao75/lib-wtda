{"version":3,"file":"stockdata.js","sources":["src/stockdata-query.js","src/stockdata-update.js"],"sourcesContent":["/**\n * TODO:\n * 1. 数据结构（对应到本地或远程存储结构）\n *\n *\n * 股票数据访问层，主要用于计算和一些处理\n * 1. 后续会将数据的远程访问，本地访问在这里集成\n * 2.\n */\n\nconst _ = require(\"lodash\");\n\nconst os = require(\"os\");\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst fp = fs.promises;\n\nconst pino = require(\"pino\");\n\nconst logger = pino({\n    // level: ,\n    prettyPrint: {\n        levelFirst: true,\n        translateTime: \"SYS:standard\",\n        crlf: true,\n    },\n    prettifier: require(\"pino-pretty\"),\n});\n\nif (process.env.LOGGER) {\n    logger.level = process.env.LOGGER;\n}\n\nconst DATA_ROOT = \".wtda\";\nconst DAILYHISTORY_PATH = \"daily\";\nconst STOCKLIST_FILE = \"stock-list.json\";\nconst INDEXLIST_FILE = \"index-list.json\";\n\nfunction getDataRoot() {\n    return path.join(os.homedir(), DATA_ROOT);\n}\n\n/**\n * 读取目前可用的完整股票列表返回，返回数据为对象\n * {\n *    info: {\n *      updateTime,\n *      ...\n *    }\n *    data: stockList[]\n * }\n *\n * stockList: [{\n *    ts_code,\n *    symbol,\n *    name,\n *    area,\n *    industry,\n *    fullname,\n *    enname,\n *    market,\n *    exchange,\n *    curr_type,\n *    list_status,\n *    delist_date,\n *    is_hs\n * }]\n *\n */\nasync function readStockList() {\n    let retData = null;\n    try {\n        await checkDataPath();\n\n        // 首先从目录中读取对应的列表文件，然后根据文件当中的信息决定是否需要更新\n        let stockListPath = path.join(getDataRoot(), STOCKLIST_FILE);\n        retData = JSON.parse(await fp.readFile(stockListPath, \"utf-8\"));\n        if (!_.isEmpty(retData)) {\n            logger.debug(`股票列表更新时间 @${retData.updateTime}`);\n        }\n    } catch (error) {\n        logger.error(`读取股票列表数据错误：${error}`);\n        throw new Error(\n            \"读取股票列表过程中出现错误，请检查后重新运行：\" + error\n        );\n        // retData = null\n    }\n\n    if (_.isEmpty(retData)) {\n        // 读取数据不存在\n        return {\n            updateTime: \"\",\n            data: [],\n        };\n    }\n    return retData;\n}\n\nasync function readStockIndexList() {\n    let retData = null;\n    try {\n        await checkDataPath();\n\n        // 首先从目录中读取对应的列表文件，然后根据文件当中的信息决定是否需要更新\n        let stockIndexListPath = path.join(getDataRoot(), INDEXLIST_FILE);\n        retData = JSON.parse(await fp.readFile(stockIndexListPath, \"utf-8\"));\n        if (!_.isEmpty(retData)) {\n            logger.debug(`指数列表更新时间 @${retData.updateTime}`);\n        }\n    } catch (error) {\n        logger.error(`读取指数列表数据错误：${error}`);\n        throw new Error(\n            \"读取指数列表过程中出现错误，请检查后重新运行：\" + error\n        );\n        // retData = null\n    }\n\n    if (_.isEmpty(retData)) {\n        // 读取数据不存在\n        return {\n            updateTime: \"\",\n            data: [],\n        };\n    }\n    return retData;\n}\n\nasync function readStockDaily(tsCode) {\n    if (_.isEmpty(tsCode)) {\n        throw new Error(\"未设置读取股票代码\");\n    }\n    let dailyData = {\n        updateTime: null,\n        data: [],\n    };\n    try {\n        await checkDataPath();\n\n        let stockDailyHistoryFile = path.join(\n            getDataRoot(),\n            DAILYHISTORY_PATH,\n            tsCode + \".json\"\n        );\n        try {\n            // await fp.access(stockDailyHistoryFile, fs.constants.F_OK)\n            dailyData = JSON.parse(\n                await fp.readFile(stockDailyHistoryFile, \"utf-8\")\n            );\n        } catch (error) {\n            // logger.debug(\"读取本地日线数据错误\", error)\n            // 文件不存在，不考虑其它错误\n            dailyData = { data: [] };\n        }\n    } catch (error) {\n        logger.error(`从本地读取日线数据时发生错误 ${error}`);\n    }\n    return dailyData;\n}\n\nasync function readStockAdjustFactor(tsCode) {\n    if (_.isEmpty(tsCode)) {\n        throw new Error(\"未设置读取股票代码\");\n    }\n    let adjData = [];\n    try {\n        await checkDataPath();\n\n        let stockAdjFile = path.join(\n            getDataRoot(),\n            DAILYHISTORY_PATH,\n            tsCode + \".adj.json\"\n        );\n        try {\n            adjData = JSON.parse(await fp.readFile(stockAdjFile, \"utf-8\"));\n        } catch (error) {\n            logger.debug(`读取股票复权因子文件${stockAdjFile} 错误：${error}`);\n            adjData = [];\n        }\n    } catch (error) {\n        logger.error(`从本地读取日线复权因子数据时发生错误 ${error}`);\n    }\n    return adjData;\n}\n\nasync function checkDataPath() {\n    let dataPath = getDataRoot(); // path.join(os.homedir, DATA_ROOT)\n\n    // 做基础的目录访问检查\n    try {\n        await fp.access(\n            dataPath,\n            fs.constants.F_OK | fs.constants.R_OK | fs.constants.W_OK\n        );\n    } catch (error) {\n        logger.debug(`检查数据根目录错误 ${error}`);\n        await fp.mkdir(dataPath, { recursive: true });\n    }\n\n    let dailyPath = path.join(dataPath, DAILYHISTORY_PATH);\n    try {\n        await fp.access(\n            dailyPath,\n            fs.constants.F_OK | fs.constants.R_OK | fs.constants.W_OK\n        );\n    } catch (error) {\n        logger.debug(`检查日线历史目录错误 ${error}`);\n        await fp.mkdir(dailyPath, { recursive: true });\n    }\n}\n\nexport {\n    readStockList,\n    readStockIndexList,\n    readStockDaily,\n    readStockAdjustFactor,\n    checkDataPath,\n    getDataRoot,\n    DATA_ROOT,\n    DAILYHISTORY_PATH,\n    STOCKLIST_FILE,\n    INDEXLIST_FILE,\n};\n","/**\n * TODO:\n * 1. 数据结构（对应到本地或远程存储结构）\n *\n *\n * 股票数据访问层，主要用于计算和一些处理\n * 1. 后续会将数据的远程访问，本地访问在这里集成\n * 2.\n */\n\nconst _ = require(\"lodash\");\nconst moment = require(\"moment\");\nconst executeTasks = require(\"@wt/lib-taskqueue\");\nconst tushare = require(\"@wt/lib-tushare\");\n\nconst pino = require(\"pino\");\n\nconst logger = pino({\n    // level: ,\n    prettyPrint: {\n        levelFirst: true,\n        translateTime: \"SYS:standard\",\n        crlf: true,\n    },\n    prettifier: require(\"pino-pretty\"),\n});\n\nif (process.env.LOGGER) {\n    logger.level = process.env.LOGGER;\n}\n\n//const tushare = require(\"./tushare\")\nimport {\n    // readStockList,\n    // readStockIndexList,\n    readStockDaily,\n    readStockAdjustFactor,\n    checkDataPath,\n    getDataRoot,\n    DAILYHISTORY_PATH,\n    STOCKLIST_FILE,\n    INDEXLIST_FILE,\n} from \"./stockdata-query\";\n//const stockData = require(\"./stockdata-query\")\n\n// const os = require(\"os\")\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst fp = fs.promises;\n\nconst QUEUE_MAX = 20;\n// const updateControl = new FlowControl(QUEUE_MAX, 0, \"更新数据控制池\");\n\n/**\n * 数据更新，如果force为true，则需要将所有数据更新为最新（相当于全部重新读取）\n * @param {boolean} force 强制更新所有数据\n */\nasync function updateData(\n    force = false,\n    includeStock = false,\n    includeFactor = false,\n    includeIndex = false,\n    all = false\n) {\n    let now = moment();\n    // let endDate = now.format(\"YYYYMMDD\")\n\n    logger.info(\"获取和更新股票列表数据 ...\");\n    logger.debug(\n        `参数：强制更新 ${force}, 全部更新 ${all}，更新股票日线 ${includeStock}, 更新指数日线 ${includeIndex}`\n    );\n    // 首先更新股票列表数据\n    let stockBasicData = await tushare.stockBasic();\n\n    let stockList = {\n        updateTime: now.toISOString(),\n        data: stockBasicData,\n    };\n    await saveListFile(stockList, STOCKLIST_FILE);\n    logger.info(\"股票列表数据更新完毕！\");\n\n    logger.info(\"获取和更新指数列表数据 ...\");\n    // 更新股票指数列表数据\n    let indexList = {\n        updateTime: now.toISOString(),\n        data: [],\n    };\n\n    // logger.debug(\"开始请求指数数据：\")\n    let allIndexData = await Promise.all(\n        tushare.indexMarketList.map(async (market) => {\n            return tushare.indexBasic(market.code);\n            // logger.debug(\"返回指数基础数据：\", indexBasicData)\n            // return indexBasicData\n        })\n    );\n\n    // logger.debug(\"所有指数请求返回！\", allIndexData && allIndexData.length)\n    if (allIndexData && allIndexData.length > 0) {\n        allIndexData.forEach((data) => {\n            // logger.debug(\"指数数据：\", data && data.length)\n            if (data && data.length > 0) {\n                // 合并之前做一次数据检查，对于已经终止的指数进行过滤\n                let total = data.length;\n                data = data.filter((item) => {\n                    return _.isEmpty(item.exp_date);\n                });\n                let filteredTotal = data.length;\n                logger.debug(`指数过滤，总共${total}, 剩余${filteredTotal}`);\n                indexList.data.push(...data);\n            }\n        });\n    }\n    // logger.debug(\"保存指数数据！\")\n    await saveListFile(indexList, INDEXLIST_FILE);\n    logger.info(\"更新指数列表数据完成！\");\n\n    if (all || includeStock) {\n        logger.info(\"开始更新股票日线数据...\");\n        // 这里直接采用Promise的方式\n        if (_.isArray(stockBasicData) && stockBasicData.length > 0) {\n            let tasks = stockBasicData.map((item) => {\n                return {\n                    caller: updateDailyData,\n                    args: [item.ts_code, force, \"S\"],\n                };\n            });\n\n            let workers = executeTasks(tasks, 20, \"股票日线更新任务\");\n\n            try {\n                logger.debug(\"等待股票日线更新队列完成...\");\n                await Promise.all(workers);\n                logger.debug(\"股票日线更新队列全部执行完毕！\");\n            } catch (error) {\n                logger.error(`股票日线任务执行 错误！${error}`);\n            }\n        }\n        logger.info(tushare.showInfo());\n        logger.info(\"股票日线数据更新完毕!\");\n    }\n\n    if (all || includeFactor) {\n        logger.info(\"开始更新股票复权因子数据...\");\n        // 这里直接采用Promise的方式\n        if (_.isArray(stockBasicData) && stockBasicData.length > 0) {\n            let tasks = stockBasicData.map((item) => {\n                return {\n                    caller: updateAdjustFactorData,\n                    args: [item.ts_code, force],\n                };\n            });\n            let workers = executeTasks(tasks, 20, \"股票复权因子更新任务\");\n            try {\n                logger.debug(\"等待股票日线复权因子更新队列完成...\");\n                await Promise.all(workers);\n                logger.debug(\"股票日线复权因子更新队列全部执行完毕！\");\n            } catch (error) {\n                logger.error(`股票日线复权因子任务执行 错误！${error}`);\n            }\n        }\n\n        logger.info(tushare.showInfo());\n        logger.info(\"股票复权因子数据更新完毕!\");\n    }\n\n    // For test\n    // let tmp = stockBasicData[0]\n    // await updateDailyData(tmp, force\n    if (all || includeIndex) {\n        logger.info(\"指数日线数据更新开始 ...\");\n        if (_.isArray(indexList.data) && indexList.data.length > 0) {\n            // indexList.data.forEach((data) => {\n            //     updateControl.call(updateDailyData, data.ts_code, force, \"I\");\n            // });\n            let tasks = indexList.data.map((data) => {\n                return {\n                    caller: updateDailyData,\n                    args: [data.ts_code, force, \"I\"],\n                };\n            });\n            let workers = executeTasks(tasks, 20, \"指数日线更新任务\");\n\n            try {\n                logger.debug(\"等待指数日线更新队列完成 ...\");\n                await Promise.all(workers);\n                logger.debug(\"指数日线数据更新队列全部完成！\");\n            } catch (error) {\n                logger.error(`指数日线任务执行 错误：%o`, error);\n            }\n\n            logger.info(tushare.showInfo());\n            logger.info(\"指数日线收护具更新完毕！\");\n        }\n    }\n\n    // logger.log(tushare.showInfo());\n}\n\n// function calculateEstimateTime(elapsed, finished, total) {\n//             // let workers = [];\n//             // let taskCount = 0;\n//             // let results = [];\n//             // let startTime = Date.now();\n//             // let finished = 0;\n//             // for (let i = 0; i < QUEUE_MAX; i++) {\n//             //     workers[i] = new Promise(async (resolve, reject) => {\n//             //         try {\n//             //             while (taskCount < stockBasicData.length) {\n//             //                 let index = taskCount;\n//             //                 let taskArgs = stockBasicData[index];\n//             //                 taskCount++;\n//             //                 logger.debug(\n//             //                     `执行池${i} - 执行第${taskCount}个任务，参数【%o】`,\n//             //                     [taskArgs.ts_code, force, \"S\"]\n//             //                 );\n//             //                 try {\n//             //                     results[index] = await updateDailyData(\n//             //                         taskArgs.ts_code,\n//             //                         force,\n//             //                         \"S\"\n//             //                     );\n//             //                 } catch (error) {\n//             //                     logger.error(\n//             //                         `执行池${i} - 执行错误，%o`,\n//             //                         error\n//             //                     );\n//             //                 }\n//             //                 finished++;\n//             //                 let elapsed = Date.now() - startTime;\n//             //                 let est = calculateEstimateTime(\n//             //                     elapsed,\n//             //                     finished,\n//             //                     stockBasicData.length\n//             //                 );\n//             //                 logger.debug(\n//             //                     `执行池${i} - 完成第${index + 1}个任务！`\n//             //                 );\n//             //                 logger.info(\n//             //                     `已经完成${finished}/${stockBasicData.length}个任务，预计还需要时间：${est}`\n//             //                 );\n//             //             }\n\n//             //             resolve();\n//             //         } catch (error) {\n//             //             reject();\n//             //         }\n//             //     });\n//             // }\n\n//     let time = (elapsed * (total - finished)) / finished;\n\n//     time = Number.parseInt(time);\n//     let ms = time % 1000;\n\n//     time = Number.parseInt(time / 1000);\n//     let sec = time % 60;\n\n//     time = Number.parseInt(time / 60);\n//     let min = time % 60;\n\n//     let hour = Number.parseInt(time / 24);\n//     return `${hour}:${min}:${sec}.${ms}`;\n// }\n\n/**\n * 更新指定代码的日历史数据\n * @param {string} tsCode 代码\n * @param {boolean} force 是否强制更新\n * @param {string} type 股票类型，S表示普通股票，I表示指数\n */\nasync function updateDailyData(tsCode, force = false, type = \"S\") {\n    // logger.log(\"更新日线：\", tsCode, force)\n    if (_.isEmpty(tsCode)) {\n        return { data: [] };\n    }\n    if (type !== \"S\" && type !== \"I\") {\n        return { data: [] };\n    }\n\n    // let tsCode = data.ts_code\n    // logger.log(\"执行更新日线：\", tsCode, force)\n    let dailyData;\n    try {\n        if (force) {\n            logger.debug(`force update ${tsCode}`);\n            let data;\n            if (type === \"S\") {\n                data = await tushare.stockDaily(tsCode);\n            } else {\n                data = await tushare.indexDaily(tsCode);\n            }\n            dailyData = {\n                updateTime: moment().toISOString(),\n                data,\n            };\n            logger.info(\n                `日线数据强制更新，代码 ${tsCode}, 更新时间：${\n                    dailyData.updateTime\n                }, 总条数：${dailyData.data && dailyData.data.length}`\n            );\n        } else {\n            dailyData = await readStockDaily(tsCode);\n\n            let startDate = \"\";\n            if (dailyData.data && dailyData.data.length > 0) {\n                let lastDate = dailyData.data[0].trade_date;\n                startDate = moment(lastDate, \"YYYYMMDD\")\n                    .add(1, \"days\")\n                    .format(\"YYYYMMDD\");\n                let now = moment();\n                if (now.diff(startDate, \"days\") <= 0 && now.hours() < 15) {\n                    // 还没有最新一天的数据，不需要\n                    logger.log(`没有新的数据，不需要更新 ${tsCode}`);\n                    return;\n                }\n            }\n\n            let newData;\n            if (type === \"S\") {\n                newData = await tushare.stockDaily(tsCode, startDate);\n            } else {\n                newData = await tushare.indexDaily(tsCode, startDate);\n            }\n            if (newData && newData.length > 0) {\n                dailyData.updateTime = moment().toISOString();\n                dailyData.data.unshift(...newData);\n                logger.info(\n                    `日线数据更新，代码 ${tsCode}, 更新时间：${\n                        dailyData.updateTime\n                    }, 更新条数：${newData && newData.length}，总条数：${\n                        dailyData.data && dailyData.data.length\n                    }`\n                );\n            } else {\n                dailyData = null;\n                logger.info(`日线数据没有更新，代码 ${tsCode}`);\n            }\n        }\n    } catch (error) {\n        logger.error(`${tsCode} 日线数据更新时发生错误，${error}`);\n        throw error;\n    }\n\n    try {\n        if (dailyData) {\n            await checkDataPath();\n\n            let jsonStr = JSON.stringify(dailyData);\n            let stockDailyFile = path.join(\n                getDataRoot(),\n                DAILYHISTORY_PATH,\n                tsCode + \".json\"\n            );\n            await fp.writeFile(stockDailyFile, jsonStr, \"utf-8\");\n        }\n    } catch (error) {\n        throw new Error(\n            \"保存日线历史数据时出现错误，请检查后重新执行：\" +\n                tsCode +\n                \",\" +\n                error\n        );\n    }\n}\n\n/**\n * 更新指定代码的复权因子历史数据\n * @param {string} tsCode 代码\n * @param {boolean} force 是否强制更新\n */\nasync function updateAdjustFactorData(tsCode, force = false) {\n    // logger.log(\"更新日线：\", tsCode, force)\n    if (_.isEmpty(tsCode)) {\n        return { data: [] };\n    }\n\n    // let tsCode = data.ts_code\n    // logger.log(\"执行更新日线：\", tsCode, force)\n    let adjData;\n    try {\n        if (force) {\n            logger.debug(`force update ${tsCode}`);\n            adjData = await tushare.adjustFactor(tsCode);\n\n            logger.info(\n                `股票复权因子数据强制更新，代码 ${tsCode}, 总条数：${\n                    adjData.data && adjData.length\n                }`\n            );\n        } else {\n            adjData = await readStockAdjustFactor(tsCode);\n\n            let startDate = \"\";\n            if (adjData && adjData.length > 0) {\n                let lastDate = adjData[0].trade_date;\n                startDate = moment(lastDate, \"YYYYMMDD\")\n                    .add(1, \"days\")\n                    .format(\"YYYYMMDD\");\n                let now = moment();\n                if (now.diff(startDate, \"days\") <= 0 && now.hours() < 15) {\n                    // 还没有最新一天的数据，不需要\n                    logger.debug(`没有新的复权因子数据，不需要更新 ${tsCode}`);\n                    return;\n                }\n            }\n\n            let newAdjData = await tushare.adjustFactor(tsCode, startDate);\n            logger.debug(\n                `${tsCode} 复权因子数据返回：${adjData && adjData.length}`\n            );\n            if (newAdjData && newAdjData.length > 0) {\n                // adjData.updateTime = moment().toISOString();\n                adjData.unshift(...newAdjData);\n                logger.info(\n                    `日线复权因子数据更新，代码 ${tsCode}, 更新条数：${\n                        newAdjData && newAdjData.length\n                    }，总条数：${adjData && adjData.length}`\n                );\n            } else {\n                adjData = null;\n                logger.info(`日线复权因子数据没有更新，代码 ${tsCode}`);\n            }\n        }\n    } catch (error) {\n        logger.error(`${tsCode} 日线复权因子数据更新时发生错误，${error}`);\n        throw error;\n    }\n\n    try {\n        if (adjData && adjData.length > 0) {\n            let jsonStr = JSON.stringify(adjData);\n            let adjFile = path.join(\n                getDataRoot(),\n                DAILYHISTORY_PATH,\n                tsCode + \".adj.json\"\n            );\n            await fp.writeFile(adjFile, jsonStr, \"utf-8\");\n        }\n    } catch (error) {\n        throw new Error(\n            \"保存复权因子数据时出现错误，请检查后重新执行：\" +\n                tsCode +\n                \",\" +\n                error\n        );\n    }\n}\n\n/**\n * 通过日期将复权因子数据合并到日线数据中，可以在后续的使用中直接使用\n * @param {Array} dailyData 日线数据\n * @param {Array} adjData 复权因子数据\n */\nasync function combineAdjustFactors(dailyData, adjData) {\n    // let retData = [];\n    if (dailyData && dailyData.length > 0) {\n        dailyData = dailyData.map((daily) => {\n            let findIndex = adjData.findIndex((adj, j) => {\n                return adj.trade_date === daily.trade_date;\n            });\n            if (findIndex >= 0 && findIndex < dailyData.length) {\n                let adj = adjData.splice(findIndex, 1)[0];\n                daily.adj_factor = adj.adj_factor;\n                // logger.debug(\n                //     `找到${daily.trade_date} 复权因子 ${adj.adj_factor}, %o`,\n                //     adj\n                // );\n            } else {\n                logger.debug(`没有找到${daily.trade_date}的复权因子`);\n            }\n            return daily;\n        });\n    }\n    return [dailyData, adjData];\n}\n\n// async function saveStockList(data) {\n//     try {\n//         await checkDataPath()\n\n//         let jsonStr = JSON.stringify(data)\n//         let stockListPath = path.join(getDataRoot(), STOCKLIST_FILE)\n\n//         await fp.writeFile(stockListPath, jsonStr, {encoding: \"utf-8\"})\n//     } catch (error) {\n//         throw new Error(\"保存股票列表数据时出现错误，请检查后重新执行：\" + error)\n//     }\n// }\n\nasync function saveListFile(data, fileName) {\n    try {\n        await checkDataPath();\n\n        let jsonStr = JSON.stringify(data);\n        let listPath = path.join(getDataRoot(), fileName);\n\n        await fp.writeFile(listPath, jsonStr, { encoding: \"utf-8\" });\n    } catch (error) {\n        throw new Error(\"保存列表数据时出现错误，请检查后重新执行：\" + error);\n    }\n}\n\n/**\n * 清除所有已经同步的数据\n */\nasync function clearAllData() {\n    try {\n        logger.debug(\"检查根目录状态：\");\n        await checkDataPath();\n\n        // 首先删除股票列表信息文件\n        logger.info(\"清理股票列表数据...\");\n        let stockListPath = path.join(getDataRoot(), STOCKLIST_FILE);\n        try {\n            await fp.access(stockListPath, fs.constants.F_OK);\n            try {\n                await fp.unlink(stockListPath);\n            } catch (error) {\n                throw error;\n            }\n        } catch (error) {\n            // 文件不存在，直接忽略\n        }\n        logger.info(\"清理股票列表数据完成\");\n\n        logger.info(\"清理指数列表数据...\");\n        let indexListPath = path.join(getDataRoot(), INDEXLIST_FILE);\n        try {\n            await fp.access(indexListPath, fs.constants.F_OK);\n            try {\n                await fp.unlink(indexListPath);\n            } catch (error) {\n                throw error;\n            }\n        } catch (error) {\n            // 文件不存在，直接忽略\n        }\n        logger.info(\"清理指数列表数据完成\");\n\n        logger.info(\"清理股票历史数据...\");\n        // 下面删除股票历史数据目录\n        let stockDailyHistoryPath = path.join(getDataRoot(), DAILYHISTORY_PATH);\n        try {\n            await fp.access(stockDailyHistoryPath, fs.constants.F_OK);\n\n            try {\n                let fileList = await fp.readdir(stockDailyHistoryPath);\n                logger.info(`共有${fileList.length}个历史数据文件待删除`);\n                fileList.forEach(async (filePath) => {\n                    // logger.log(\"to be remove: \", filePath)\n                    await fp.unlink(path.join(stockDailyHistoryPath, filePath));\n                });\n            } catch (error) {\n                throw error;\n            }\n        } catch (error) {\n            // 没有目录\n        }\n        logger.info(\"清理股票历史数据完成\");\n    } catch (error) {\n        throw new Error(\"清除所有已经同步数据发生错误：\" + error);\n    }\n}\n\nexport { clearAllData, updateData, updateDailyData, updateAdjustFactorData };\n"],"names":["_","require","os","path","fs","fp","promises","logger","pino","prettyPrint","levelFirst","translateTime","crlf","prettifier","process","env","LOGGER","level","getDataRoot","join","homedir","async","readStockDaily","tsCode","isEmpty","Error","dailyData","updateTime","data","checkDataPath","stockDailyHistoryFile","JSON","parse","readFile","error","dataPath","access","constants","F_OK","R_OK","W_OK","debug","mkdir","recursive","dailyPath","moment","executeTasks","tushare","updateDailyData","force","type","stockDaily","indexDaily","toISOString","info","length","newData","startDate","lastDate","trade_date","add","format","now","diff","hours","log","unshift","jsonStr","stringify","stockDailyFile","writeFile","updateAdjustFactorData","adjData","adjustFactor","stockAdjFile","readStockAdjustFactor","newAdjData","adjFile","saveListFile","fileName","listPath","encoding","stockListPath","unlink","indexListPath","stockDailyHistoryPath","fileList","readdir","forEach","filePath","retData","stockIndexListPath","includeStock","includeFactor","includeIndex","all","stockBasicData","stockBasic","stockList","indexList","allIndexData","Promise","indexMarketList","map","indexBasic","market","code","total","filteredTotal","filter","item","exp_date","push","isArray","tasks","caller","args","ts_code","workers","showInfo"],"mappings":"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"}